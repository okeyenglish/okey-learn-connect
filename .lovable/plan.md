
## Что происходит сейчас (почему “даже не было попытки”)

По вашему скрину видно, что провайдер фиксирует ошибки `PEER_NOT_FOUND` и в поле “Получатель” фигурирует число `1212686911`.

С текущей реализацией есть 2 типовые причины, почему **вторая попытка по телефону реально не делается**:

1) **ID ошибочно трактуется как “телефон”**  
   В `telegram-send` функция `normalizePhone()` сейчас возвращает “телефон” почти для любого числа длиной ≥10 (даже если это Telegram ID).  
   Если Telegram ID попал в `clients.phone` или `client_phone_numbers.phone_number`, код считает это телефоном, ставит `recipientSource = 'phone...'`, и дальше `usedIdNotPhone` становится `false` → fallback не запускается.

2) **Телефон для fallback не найден/невалиден**  
   Даже если отправка была по ID (и `usedIdNotPhone=true`), fallback не случится, если `phoneToTry` вычислился как `null` или совпал с `recipient` (и тогда попытка пропускается).

Нужно сделать так, чтобы:
- телефон брался гарантированно из правильного поля,
- “телефон” строго валидировался как телефон (а не любое 10–15-значное число),
- fallback запускался всегда, когда первая отправка была по **Telegram-идентификатору** (id/username/chat_id) или когда “получатель-цифры” не похож на телефон.

---

## Цель изменения

Если отправка **по ID** (telegram_user_id / telegram_chat_id / telegram_username) дала ошибку — **обязательно** сделать вторую попытку **по телефону клиента** (нормализованному), чтобы в логах провайдера появилась вторая запись уже с номером телефона.

Важно: даже если телефонная попытка тоже упадёт с `PEER_NOT_FOUND` (например, контакт не добавлен в адресную книгу аккаунта), мы хотя бы увидим факт попытки и будем понимать, что fallback реально отработал.

---

## Где меняем

1 файл:
- `supabase/functions/telegram-send/index.ts`

(Даже если вы используете только self-hosted, этот файл — источник правок; дальше вы обновляете вашу self-hosted функцию тем же кодом.)

---

## План работ (пошагово)

### Шаг 1. Сделать “строгую” нормализацию телефона (чтобы Telegram ID не считался телефоном)
Внутри `telegram-send` заменить/расширить `normalizePhone()` так, чтобы она:
- принимала **только телефон-похожее** (для РФ логика уже есть у вас на фронте; в функции повторим её упрощённо),
- **возвращала null**, если число похоже на Telegram ID (например 10 цифр, но не начинается с `9`; 11 цифр, но `7` + вторая цифра `0/1/2`, и т.п.).

Ожидаемый эффект: число `1212686911` больше не будет “валидным телефоном”, значит не попадёт в `recipientSource = phone...` и не будет блокировать fallback.

### Шаг 2. Во время выбора получателя сохранить “лучший телефон для fallback”
Пока мы определяем `recipient` (из `phoneRecord`, `primaryPhone`, `client`), параллельно сохранить:
- `fallbackPhoneRaw` (строка телефона из БД)
- `fallbackPhoneNormalized` (после строгой нормализации)

Приоритет источников телефона для fallback (в self-hosted, где таблицы есть):
1) `client_phone_numbers.phone_number` из **той же записи**, откуда взяли telegram_user_id/chat_id (если был `phoneId`)
2) `client_phone_numbers.phone_number` из primary-записи
3) `clients.phone`
4) любая `client_phone_numbers.phone_number` (первую попавшуюся)

Так мы не будем зависеть от того, заполнен ли `clients.phone`.

### Шаг 3. Исправить условие запуска fallback (чтобы он точно стартовал)
Сейчас fallback запускается, если `usedIdNotPhone === true`.

Сделаем условие более надёжным:
- “первая попытка была по ID”, если:
  - `recipientSource` содержит `telegram_chat_id` / `telegram_user_id` / `telegram_username`
  - **или** `recipient` выглядит как число, но **не** выглядит как валидный телефон (по новой строгой проверке)

Тогда даже если ID лежит в phone-полях и раньше считался телефоном — fallback всё равно сработает.

### Шаг 4. Гарантировать попытку по телефону (и чтобы это было видно в Wappi-логах)
Если первая отправка неуспешна и условие fallback выполнено:
- берём `fallbackPhoneNormalized`
- если он есть и не равен `recipient` → делаем **второй вызов** `sendTextMessage/sendFileMessage` уже на телефон
- логируем:
  - что именно было первым получателем и источником,
  - какой телефон взяли,
  - что реально делаем второй запрос

После этого в логах провайдера должна появиться **вторая строка** с “Получатель = 7XXXXXXXXXX”.

### Шаг 5. Мини-диагностика “правильный ли ID”
Чтобы быстро ответить на ваш вопрос “точно правильный ID?” и не гадать:
- добавим в логи функции вывод:
  - `Final recipient`, `recipientSource`,
  - и отдельно: `fallbackPhoneNormalized`
- это позволит сопоставить с вашим скрином: если “Final recipient” = `1212686911`, значит функция реально пыталась по этому ID.
- если ID “правильный”, но `PEER_NOT_FOUND`, чаще всего это означает: у аккаунта нет peer (контакт/диалог) — тогда телефонная попытка может помочь только если номер есть в контактах аккаунта.

---

## Как проверяем (на self-hosted)

1) Выберите клиента, у которого:
   - `telegram_user_id` заполнен (или другой Telegram ID),
   - при этом есть корректный телефон в `client_phone_numbers.phone_number` или `clients.phone`.

2) Отправьте сообщение из CRM.

3) Ожидаемое в логах провайдера:
   - первая запись: recipient = Telegram ID (например `1212686911`) → ошибка
   - вторая запись: recipient = телефон (например `79XXXXXXXXX`) → успех или ошибка (но факт второй попытки обязателен)

4) Если вторая попытка тоже `PEER_NOT_FOUND`:
   - это уже “функция работает”, но провайдер/Telegram не может открыть peer по телефону без наличия контакта/диалога.

---

## Риски и нюансы

- Если в базе в “телефонных” полях реально лежат Telegram ID (как у вас похоже по скрину), строгая нормализация перестанет считать их телефоном — это правильно, иначе мы никогда не отличим телефон от ID.
- Если у клиента вообще нет валидного телефона, fallback сделать физически невозможно — тогда будет лог “No phone available for fallback” и корректная ошибка.

---

## Техническая часть (что именно будет изменено в коде)

- В `telegram-send/index.ts`:
  1) заменить `normalizePhone()` на строгую версию + добавить `isLikelyPhoneNumber()` (локально в функции, без импортов)
  2) в блоках, где берём `phone_number` и `client.phone`, вычислять и сохранять `fallbackPhoneNormalized`
  3) в fallback-блоке:
     - вычислять `firstAttemptWasIdLike`
     - использовать `fallbackPhoneNormalized` как основной кандидат
     - всегда делать второй вызов при ошибке первой попытки, если телефон доступен

