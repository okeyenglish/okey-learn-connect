
## Диагностика: почему менеджеры не видят клиентов

По текущему коду (и по симптомам “менеджер Новокосино не видит вообще никого”) наиболее вероятно, что происходит одно из двух:

1) **Фильтрация по филиалу реально включилась (hasRestrictions=true), но сравнение филиалов всегда “не совпало”**, поэтому `canAccessBranch()` возвращает `false` для всех клиентских чатов.  
Причина обычно в **разных написаниях/символах** (типографский апостроф `’` вместо `'`, неразрывные пробелы, “м. Новокосино”, “Новокосино ”, “O’KEY” и т.п.), которые текущая нормализация не отлавливает.

2) **Локальный фильтр UI по выбранному филиалу (selectedBranch)** мог “застрять” в localStorage в старом формате и теперь не матчится с текущей нормализацией. Тогда список может стать пустым даже без branch-restrictions.

Чтобы не гадать, сделаем диагностику так, чтобы она сама показала, на каком шаге “обнуливается” список.

---

## Что нужно сделать в коде (чтобы проблема точно ушла)

### 1) Убрать зависимость `useManagerBranches` от `selfHostedPost('get-user-branches')`
Сейчас `useManagerBranches` зовёт **self-hosted backend function** `get-user-branches`, но эта функция легко может отсутствовать/быть недоступной/иметь RLS-ограничения, и главное — это лишняя точка отказа.

План: переделать `useManagerBranches` так, чтобы он **читал филиалы напрямую через существующий backend-клиент** (который уже настроен на self-hosted `api.academyos.ru`), с тем же порядком fallback:

- `manager_branches` по `manager_id = user.id`
- если пусто/таблица отсутствует → `user_branches` по `user_id = user.id`
- если пусто → `profiles.branch` по `id = user.id`
- если совсем ничего → “нет ограничений” (или “fail-closed” — см. пункт 4 ниже)

Это сразу даст:
- понятные ошибки (если таблицы/права недоступны),
- единый auth-контекст (текущий пользователь),
- меньше сетевого шума.

### 2) Сделать ЕДИНУЮ нормализацию филиала и использовать её везде
Сейчас нормализация разная в:
- `useManagerBranches.ts`
- `CRM.tsx` (selectedBranch фильтр)
- `useUserAllowedBranches.ts`
- местами есть ещё `src/lib/branchNameMap.ts`, но он решает другую задачу (в основном для фото/витрины)

План: вынести одну функцию, условно `toBranchKey(name)`, и использовать её:
- в `useManagerBranches` для вычисления `allowedBranchKeys`
- в `CRM.tsx` для:
  - генерации `branchKey` в dropdown
  - фильтра по `selectedBranch`
  - авто-фильтра `canAccessBranch`
- в `useUserAllowedBranches` для `canAccessBranch`

**Какая нормализация нужна, чтобы закрыть реальные кейсы:**
- `name.normalize('NFKC')` (чинит часть “невидимых” отличий)
- `toLowerCase()`
- `ё → е`
- заменить все варианты апострофов/кавычек на обычные или удалить: `' ’ ʻ ʼ " « »`
- убрать токены бренда и служебные слова независимо от апострофа/пробелов:
  - `okey`, `o’key`, `o'key`, `english`
  - `филиал`, `branch`
- убрать пунктуацию → пробел
- схлопнуть пробелы
- применить **alias-map** (важно):  
  например (из вашего `branchNameMap.ts` и реальных кейсов):
  - `стахановская` ↔ `грайвороновская`
  - `красная горка` → `люберцы`
  - `онлайн`, `онлайн школа` → `online school`
  - и при необходимости: `м. новокосино` → `новокосино`

Идея простая: в сравнении участвует не “красивое название”, а **устойчивый ключ**.

### 3) Миграция старого `selectedBranch` из localStorage (чтобы UI-фильтр не “убивал” список)
У вас выбранный филиал хранится в `localStorage` (`crm-selected-branch`). Если там лежит старое значение (например полное “O’KEY ENGLISH Новокосино”), а сейчас UI ожидает “ключ” (например “новокосино”), то фильтр в `CRM.tsx` может не совпасть и скрыть всё.

План:
- при инициализации `usePersistedBranch` (или в `CRM.tsx` рядом) делать:
  - если `selectedBranch !== 'all'` → преобразовать через `toBranchKey(selectedBranch)` и сохранить обратно
  - если преобразование дало пусто/мусор → сбросить на `'all'`
- дополнительно: если `selectedBranch` не входит в список доступных ключей dropdown — тоже сброс на `'all'` (защита от устаревших значений)

### 4) Добавить “диагностический режим” прямо в CRM (чтобы сразу видеть причину пустого списка)
Чтобы больше не упираться в “не вижу и не понимаю почему”, добавим лёгкую диагностику:

- Посчитать:
  - `threadsCount` (до фильтров)
  - `afterSelectedBranchCount`
  - `afterManagerRestrictionCount`
- Если `threadsCount > 0`, но после авто-фильтра стало `0`, показать баннер:
  - “Нет клиентов по вашим филиалам”
  - “Ваши филиалы: …”
  - “Примеры филиалов клиентов в списке: … (первые 10 уникальных)”
  - “Сбросить фильтр филиала” (кнопка → setSelectedBranch('all'))

Важно: без персональных данных, только агрегаты/уникальные названия филиалов.

### 5) (Опционально, но желательно) Убрать/обезопасить Lovable Cloud function `get-user-branches`
Сейчас в репозитории есть backend-функция `supabase/functions/get-user-branches`, которая подключается к self-hosted по anon key и при этом ключ захардкожен в коде. Даже если она не используется фронтом, это:
- создаёт путаницу “какая функция где живёт”
- несёт риск утечки

План:
- либо полностью убрать её из цепочки (после пункта 1 она станет не нужна),
- либо перевести на secrets (`SELF_HOSTED_URL`, `SELF_HOSTED_ANON_KEY`) и явно пометить как “не используется фронтом”.

---

## Как мы проверим, что всё исправилось (чеклист)
1) Зайти под менеджером Новокосино:
   - `selectedBranch = Все филиалы`
   - менеджер видит клиентов с ветками:
     - `Новокосино`
     - `O'KEY ENGLISH Новокосино`
     - `O’KEY ENGLISH Новокосино` (типографский апостроф)
2) Менеджер не видит клиентов Окской.
3) Менеджер с двумя филиалами видит оба.
4) Админ видит всех.
5) Если клиент без филиала (`branch = null`) — он скрыт только для менеджеров с активными ограничениями (как и задумано), но админ его видит.

---

## Риски/краевые случаи, которые учтём
- “Филиал” записан с нестандартными пробелами/кавычками → лечит `normalize('NFKC')` + чистка
- alias-ветки (“Стахановская” vs “Грайвороновская”) → лечит alias-map
- устаревший `selectedBranch` в localStorage → лечит миграция/сброс
- если таблицы ограничений недоступны по правам → диагностика покажет ошибку получения филиалов (и можно выбрать поведение: fail-open или fail-closed)

---

## Что мне нужно от вас для максимально точной подгонки alias-map (если после унификации ещё останутся “пустые” списки)
Если после внедрения единого `toBranchKey` всё равно будет 0, тогда в баннере/логах будут видны:
- `allowedBranchesRaw` (как хранится у менеджера)
- `uniqueClientBranchesRaw` (как приходит у клиентов)

По этим двум спискам мы добавим 1–3 alias-правила и закроем остаточные расхождения.
